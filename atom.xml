<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://arms-merchants.github.io/</id>
    <title>Arms-merchants</title>
    <updated>2024-01-05T08:06:39.076Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://arms-merchants.github.io/"/>
    <link rel="self" href="https://arms-merchants.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://arms-merchants.github.io/images/avatar.png</logo>
    <icon>https://arms-merchants.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, Arms-merchants</rights>
    <entry>
        <title type="html"><![CDATA[在AndroidStudio Hedgehog中使用Bito插件错误的解决方案]]></title>
        <id>https://arms-merchants.github.io/post/zai-androidstudio-hedgehog-zhong-shi-yong-bito-cha-jian-cuo-wu-de-jie-jue-fang-an/</id>
        <link href="https://arms-merchants.github.io/post/zai-androidstudio-hedgehog-zhong-shi-yong-bito-cha-jian-cuo-wu-de-jie-jue-fang-an/">
        </link>
        <updated>2024-01-05T06:40:41.000Z</updated>
        <content type="html"><![CDATA[<p>这段时间一直在AS中使用Bito这个基于ChatGPT的插件，当然了白漂为主，所以用的都是免费版的，不过一些问题基本都能解决，不能话就换一家🐶。<br>
不过吗在愉快的玩耍了一段时间，然后手不受控制的将AS更新到最新了，愉快不起来了。。。。</p>
<h2 id="gpu-process-restarts-too-many-times-and-seems-to-be-unstable-try-to-restart-ide-or-disable-gpu-acceleration-completely">GPU process restarts too many times and seems to be unstable. Try to restart IDE or disable GPU acceleration completely.</h2>
<p>然后Bito就加载不出来了，尝试将插件重装也一样的效果。最后只有降级回Giraffe版本才能正常使用。<br>
不过最近在Bito的github仓库的issues中看到了个解决方案，尝试成功解决了我的问题，如何你是和我一样的错误，可以考虑尝试该方法：<br>
1.在Help菜单中选择Find Action<br>
2.输入Registry选择Registry...<br>
3.在出现的列表中找到ide.browser.jcef.sandbox.enable选项，将它禁用调<br>
4.重启<br>
然后应该能继续调戏BitoAi了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Compose来开发WanAndroidApp碰到的一些问题集锦]]></title>
        <id>https://arms-merchants.github.io/post/shi-yong-compose-lai-kai-fa-wanandroidapp-peng-dao-de-yi-xie-wen-ti-ji-jin/</id>
        <link href="https://arms-merchants.github.io/post/shi-yong-compose-lai-kai-fa-wanandroidapp-peng-dao-de-yi-xie-wen-ti-ji-jin/">
        </link>
        <updated>2023-05-25T06:17:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1lzaycloumn页面重新展示的时候出现重新定位到顶部的问题">1.LzayCloumn页面重新展示的时候出现重新定位到顶部的问题</h2>
<h3 id="11问题场景">1.1问题场景：</h3>
<p>使用Pagin加载分页数据，并显示在A的LazyColumn上，向下滑动LazyColumn，然后通过navigation.navigate跳转到页面B，接着再navigatUp回到页面A，页面A的LazyColumn又回到列表顶部。</p>
<h3 id="12分析">1.2分析：</h3>
<p>LazyColumn默认的参数state是有通过rememberLazyListState()来做持久化保存的。如果LazyColumn内部只包含一个items来创建子列表的话，那么是没有问题的，如果是内部通过item来创建了Header活着Footer就不行了。<br>
这是因为rememberLazyListState会在列表中至少有一项时restore滚动位置，同时Paging是通过Flow获取数据的，当返回到页面重组时并不能马上获取到Paging数据，第一帧时Paging的itemCount为0<br>
但同时因为LazyColumn中已经有了一个Header，这时便会还原保存的位置，但因为这时Paging中的数据还为空，不能滚动到正确的位置，于是便又滚动到顶部了<br>
而当LazyColumn中没有Header时，列表中至少有一项时便是Paging数据成功填充的时候，这个时候还原的位置就是对的,所以没有问题。</p>
<h3 id="13解决问题">1.3解决问题：</h3>
<p>既然原因在于LazyListState没有在正确的时机被还原，那我们将LazyListSate保存在ViewModel中,并且在Paging中有数据时再还原listState，如下所示：</p>
<pre><code class="language-java">@HiltViewModel
class SquareViewModel @Inject constructor(
    private var service: HttpService,
) : ViewModel() {
    private val pager by lazy { simplePager { service.getSquareData(it) }.cachedIn(viewModelScope) }
    val listState: LazyListState = LazyListState()
}
 
@Composable
fun SquarePage(
    navCtrl: NavHostController,
    scaffoldState: ScaffoldState,
    viewModel: SquareViewModel = hiltViewModel()
) {
    val squareData = viewStates.pagingData.collectAsLazyPagingItems()
    // 当`Paging`有数据时，返回`ViewModel`中的`listState`
    val listState = if (squareData.itemCount &gt; 0) viewStates.listState else LazyListState()
 
    RefreshList(squareData, listState = listState) {
        itemsIndexed(squareData) { _, item -&gt;
           //...
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读KotlinCompose从入门到实战读书笔记一]]></title>
        <id>https://arms-merchants.github.io/post/compose-yi/</id>
        <link href="https://arms-merchants.github.io/post/compose-yi/">
        </link>
        <updated>2023-05-17T11:36:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1compose基本概念">1.Compose基本概念</h2>
<p>相较于之前基于view体系的UI，Compose是Android全新的声明式UI，那么声明式和命令式的区别是什么？<br>
基于View体现的UI就是典型的命令式UI，我们需要一步步的告诉程序怎么取执行，我们需要获取控件，然后给控件设置对应的属性，而控件会持有相应的属性值，相当于控件是持有状态的。但是声明式UI是我们告诉程序我想要怎么样，剩下的由程序处理。</p>
<h2 id="2设置项目支持compose">2.设置项目支持Compose</h2>
<p>build.gradle的相关配置</p>
<pre><code class="language-java">android{
    ...
    //compose是基于单一语言(Kotlin)的
    kotlinOptions {
        jvmTarget = '1.8'
    }
    buildFeatures {
        compose true
    }
    composeOptions {
        kotlinCompilerExtensionVersion '1.2.0'
    }
    packagingOptions {
        resources {
            excludes += '/META-INF/{AL2.0,LGPL2.1}'
        }
    }
}
dependencies{
    ...
    //ComponentActivity
    implementation 'androidx.activity:activity-compose:1.4.0'
    //compose的基础库
    implementation &quot;androidx.compose.ui:ui:$compose_ui_version&quot;
    //用于compose的预览
    implementation &quot;androidx.compose.ui:ui-tooling-preview:$compose_ui_version&quot;
    //Material的compose
    implementation 'androidx.compose.material:material:1.2.0'
    //compose版本的constraintlayout
    implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.1&quot;
    //一个图片加载框架
    implementation &quot;io.coil-kt:coil-compose:2.2.2&quot;
    //compose版本的livedata
    implementation &quot;androidx.compose.runtime:runtime-livedata:$compose_ui_version&quot;
}
</code></pre>
<p>如果是通过AS来直接生成一个Compose项目的话，上面部分配置和依赖都会已经添加好，不过我们也可以自行配置嘛，Compose是支持和原生项目混编的，支持在Compose中使用原生View体系，也支持在原生的View体系中使用Compose。<br>
来看一下通过AS直接创建一个空的Compose项目的MainActivity</p>
<pre><code class="language-java">//继承的是ComponentActivity
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        //设置了个沉浸，非必须
        WindowCompat.setDecorFitsSystemWindows(window, false)
        val controller = WindowCompat.getInsetsController(window, window.decorView)
        controller.isAppearanceLightStatusBars = true
        //设置内容
        setContent {
            //在ui/theme/下Theme.kt中配置的主体
            StComposeTheme {
                //具体的控件后面再说，这里可以理解为全屏，背景色为StComposeTheme中配置的background的color
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colors.background
                ) {
                    Greeting(&quot;Android&quot;)
                }
            }
        }
    }
    /**
    声明的一个Compose函数，@Preview可以预览当前Compose的样式，不过需要注意有参数的话记得给出默认值
    */
    @Preview(showBackground = true)
    @Composable
    fun Greeting(str:String = &quot;123&quot;){
        //就一个文本控件
        Text(text = str)
    }
}
</code></pre>
<p>Compose函数预览效果<br>
<img src="https://arms-merchants.github.io//post-images/1684293710477.png" alt="" loading="lazy"><br>
不过现在Greeting函数非常简单，下面我们来构建一个复杂的页面：<br>
先看预览的效果图：<br>
<img src="https://arms-merchants.github.io//post-images/1684294378624.png" alt="" loading="lazy"></p>
<pre><code class="language-java">@Composable
fun Greeting(name: String) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            //compose中只有padding的概念，根据调用的顺序可以实现原来的外边距和内边距的效果
            //这里设置的就是外边距
            .padding(8.dp)
            //设置边框 宽2dp 黄色 圆角为2dp
            .border(2.dp, Color.Yellow, shape = RoundedCornerShape(2.dp))
            .background(color = Color.Red)
            .padding(8.dp)
    ) {
        Spacer(
            //注意这里的Modifier，因为它是在BoxScope的中，所以它可以设置的方法会多出两个分别是align和matchParenSize，这是在Box中的Modifier中不具备的
            modifier = Modifier
                .matchParentSize()
                .background(color = Color.Green)
        )
    }
    //定义个列表
    Column {
        //文本控件
        Text(text = &quot;Hello $name!&quot;)
        //因为Compose中没有Margin的概念，不过可以通过Spacer来设置两个控件之间的间距
        Spacer(modifier = Modifier.height(10.dp))
        //图片控件
        Image(
            //使用本地图片资源的方式
            painter = painterResource(id = R.mipmap.ic_hotel_share_img),
            //描述信息，可以为空
            contentDescription = null,
            //设置图片的宽高以及裁剪样式为圆形
            modifier = Modifier
                .size(width = 200.dp, height = 200.dp)
                .clip(CircleShape)
        )
        Spacer(modifier = Modifier.height(10.dp))
        Box(
            modifier = Modifier
                .size(50.dp)
                .background(color = Color.Red)
        ) {
            Text(text = &quot;纯色&quot;, Modifier.align(Alignment.Center))
        }
        Spacer(modifier = Modifier.height(10.dp))
        Box(
            modifier = Modifier
                .size(50.dp)
                .background(
                    //背景的渐变效果
                    brush = verticalGradientBrush1
                )
        ) {
            Text(text = &quot;渐变色&quot;, Modifier.align(Alignment.Center))
        }
        Spacer(modifier = Modifier.height(10.dp))
        Box(
            modifier = Modifier
                .size(100.dp)
                //设置偏移量
                //.offset(50.dp, 50.dp)
                //offset的重载方法
                .offset { IntOffset(50.dp.roundToPx(), 50.dp.roundToPx()) }
                .background(color = Color.Yellow)
        )
    }
}

//两种创建渐变色的方式
//方式一给定颜色列表，颜色均匀分布
val verticalGradientBrush1 = Brush.verticalGradient(
    colors = listOf(Color.Red, Color.Yellow, Color.White)
)
//给定偏移量和颜色
val verticalGradientBrush2 = Brush.verticalGradient(
    //0-0.1显示红色
    0.1f to Color.Red,
    //0.1-0.3显示红到绿色的渐变
    0.3f to Color.Green,
    //0.3-0.9显示绿色到蓝色的渐变
    0.9f to Color.Blue
)

</code></pre>
<h2 id="3关于scopse的举例说明">3.关于Scopse的举例说明</h2>
<p>在Compose所提供的控件都是有一个content参数，这就是每个的作用域</p>
<pre><code class="language-java">@Composable
inline fun Box(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    propagateMinConstraints: Boolean = false,
    content: @Composable BoxScope.() -&gt; Unit
) {
    val measurePolicy = rememberBoxMeasurePolicy(contentAlignment, propagateMinConstraints)
    Layout(
        content = { BoxScopeInstance.content() },
        measurePolicy = measurePolicy,
        modifier = modifier
    )
}
</code></pre>
<p>在之前的View体系中，例如在xml布局中我们可以给一个子view设置android：layout_toRight属性，哪怕它的外层布局是Linerlayout布局，这个属性并不会生效。<br>
而在Compose中通过Scope限制对应属性能够生效的范围,下面是BoxScope的代码，通过@LayoutScopeMarker元注解，除了是Modifier的公共属性外，那么在特定Scope中定义的方法，只能在对应的作用域来调用。就像下面的BoxScope，它内部定义有两个方法align和matchParentSize，那么这两个方法只能在BoxScope作用域内调用。</p>
<pre><code class="language-java">@LayoutScopeMarker
@Immutable
interface BoxScope {
    /**
     * Pull the content element to a specific [Alignment] within the [Box]. This alignment will
     * have priority over the [Box]'s `alignment` parameter.
     */
    @Stable
    fun Modifier.align(alignment: Alignment): Modifier

    /**
     * Size the element to match the size of the [Box] after all other content elements have
     * been measured.
     *
     * The element using this modifier does not take part in defining the size of the [Box].
     * Instead, it matches the size of the [Box] after all other children (not using
     * matchParentSize() modifier) have been measured to obtain the [Box]'s size.
     * In contrast, a general-purpose [Modifier.fillMaxSize] modifier, which makes an element
     * occupy all available space, will take part in defining the size of the [Box]. Consequently,
     * using it for an element inside a [Box] will make the [Box] itself always fill the
     * available space.
     */
    @Stable
    fun Modifier.matchParentSize(): Modifier
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin关键字by lazy中的Mode分析]]></title>
        <id>https://arms-merchants.github.io/post/kotlin-guan-jian-zi-by-lazy-zhong-de-mode-fen-xi/</id>
        <link href="https://arms-merchants.github.io/post/kotlin-guan-jian-zi-by-lazy-zhong-de-mode-fen-xi/">
        </link>
        <updated>2023-05-16T08:42:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">    class TestManager private constructor(){
        companion object{
            val instance by lazy(LazyThreadSafetyMode.SYNCHRONIZED){
                TestManager()
            }
        }
    }
</code></pre>
<p>上面代码是常见的Kotlin中通过by关键字来创建单例对象的实现，但lazy中的Mode是什么呢？<br>
了解这些之前，我们先简单分别说下lazy和by，其中by是Kotlin中用于委托的关键字，而lazy是一个方法，其返回值是委托的具体对象。by lazy用于实现数据的惰性加载，在初始化一个常量时确保其不会被多次初始化。<br>
LazyThreadSafetyMode的值有三个，通过它来确定对象的创建模式：</p>
<ul>
<li>LazyThreadSafetyMode.SYNCHRONIZED</li>
<li>LazyThreadSafetyMode.PUBLICATION</li>
<li>LazyThreadSafetyMode.NONE</li>
</ul>
<p>lazy方法默认是使用SynchronizedLazyImpl来返回委托的具体对象的。<br>
Lazy实现了by lazy的方法：</p>
<pre><code class="language-java">@kotlin.internal.InlineOnly
public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value
</code></pre>
<p>也就是我们的获取到的值就是这个value，那么我们就要来看这个value是怎么获取到的。分析三种Mode下value不同取值，可以确定后续我们在使用by lazy时应该使用那种Mode，首先先看SynchronizedLazyImpl的实现：</p>
<pre><code class="language-java">private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable {
    //lazy后的方法体，返回当前需要创建的对象
    private var initializer: (() -&gt; T)? = initializer
    //默认值，定义了一个未初始化的值，为了解决DCL带来指令重排序导致主存和工作内存数据不一致的问题，这里使用Volatile原语注解，线程安全
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    //锁
    // final field is required to enable safe publication of constructed instance
    private val lock = lock ?: this

    override val value: T
        //获取value的值就是通过get方法
        get() {
            val _v1 = _value
            //如果当前的值已经不是未初始化的了那么直接返回
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress(&quot;UNCHECKED_CAST&quot;)
                return _v1 as T
            }

            return synchronized(lock) {
                //双重检测
                val _v2 = _value
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T)
                } else {
                    //如果没有初始化，那么通过initializer来进行初始化操作
                    val typedValue = initializer!!()
                    //并将这个值保存在_value中
                    _value = typedValue
                    initializer = null
                    typedValue
                }
            }
        }

    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE

    override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot;

    private fun writeReplace(): Any = InitializedLazyImpl(value)
}
</code></pre>
<p>SafePublicationLazyImpl的实现：</p>
<pre><code class="language-java">private class SafePublicationLazyImpl&lt;out T&gt;(initializer: () -&gt; T) : Lazy&lt;T&gt;, Serializable {
    @Volatile private var initializer: (() -&gt; T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    // this final field is required to enable safe initialization of the constructed instance
    private val final: Any = UNINITIALIZED_VALUE

    override val value: T
        get() {
            val value = _value
            if (value !== UNINITIALIZED_VALUE) {
                @Suppress(&quot;UNCHECKED_CAST&quot;)
                return value as T
            }
            val initializerValue = initializer
            // if we see null in initializer here, it means that the value is already set by another thread
            if (initializerValue != null) {
                   //如果是多线程的话，初始化方法会调用多次
                val newValue = initializerValue()
                //通过CAS保证只有在原始值为UNINITIALIZED_VALUE时赋值
                if (valueUpdater.compareAndSet(this, UNINITIALIZED_VALUE, newValue)) {
                    initializer = null
                    return newValue
                }
            }
            @Suppress(&quot;UNCHECKED_CAST&quot;)
            return _value as T
        }

    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE

    override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot;

    private fun writeReplace(): Any = InitializedLazyImpl(value)

    companion object {
        private val valueUpdater = 
        //java中的原子操作
        java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater(
            SafePublicationLazyImpl::class.java,
            Any::class.java,
            &quot;_value&quot;
        )
    }
}
</code></pre>
<p>UnsafeLazyImpl的实现：</p>
<pre><code class="language-java">internal class UnsafeLazyImpl&lt;out T&gt;(initializer: () -&gt; T) : Lazy&lt;T&gt;, Serializable {
    private var initializer: (() -&gt; T)? = initializer
    private var _value: Any? = UNINITIALIZED_VALUE

    override val value: T
        get() {
            //只是是未初始化那么就调用初始化方法
            //多线程的情况下，那么它的值为最后的赋值方法，线程不安全
            if (_value === UNINITIALIZED_VALUE) {
                _value = initializer!!()
                initializer = null
            }
            @Suppress(&quot;UNCHECKED_CAST&quot;)
            return _value as T
        }

    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE

    override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot;

    private fun writeReplace(): Any = InitializedLazyImpl(value)
}
</code></pre>
<p>经过上面的源码分析，我们不难看出三种Mode的区别：</p>
<ul>
<li>LazyThreadSafetyMode.SYNCHRONIZED 通过synchronized关键值创建同步锁来实现线程安全</li>
<li>LazyThreadSafetyMode.PUBLICATION 通过CAS来保证线程安全，多线程的情况下初始化方法会调用，但只有一个生效。</li>
<li>LazyThreadSafetyMode.NONE，只要标识为未初始化就调用初始化来赋值，线程不安全。</li>
</ul>
<p>所以经过上面的分析，在确定当前属性不会在多个线程之间共享的时候，则可以使用NONE模式，这是最快的模式，但也是最不安全的模式。<br>
如果属性是要在多个线程间共享，那么使用SYNCHRONIZED和PUBLICATION，但因为SYNCHRONIZED引入了锁的机制，它是最安全的，但也是最慢的模式。折中的话则可以使用PUBLICATION。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对Closeable的自动关闭处理，语法🍬]]></title>
        <id>https://arms-merchants.github.io/post/dui-closeable-de-zi-dong-guan-bi-chu-li-yu-fa/</id>
        <link href="https://arms-merchants.github.io/post/dui-closeable-de-zi-dong-guan-bi-chu-li-yu-fa/">
        </link>
        <updated>2022-06-14T01:30:07.000Z</updated>
        <content type="html"><![CDATA[<p>首先看一段示例代码：</p>
<pre><code class="language-java"> FileInputStream fis = null;
        try {
            fis = new FileInputStream(&quot;&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
</code></pre>
<p>一段基本操作，对文件流进行操作那么不论成功还是失败最好都要进行文件流的关闭。不过这样的代码确实挺样板的。我们看下java和kotlin对这中样本代码消除的语法糖实现。</p>
<h2 id="1java的实现">1.java的实现</h2>
<pre><code class="language-java">     try (FileInputStream fis = new FileInputStream(&quot;file_path&quot;);
             FileOutputStream fos = new FileOutputStream(&quot;file_path&quot;)) {
            byte[] bytes = new byte[1024];
            while ( fis.read(bytes) != -1) {
                fos.write(bytes);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
</code></pre>
<p>跟原来的写法唯一的区别就是将Closeable对象的声明是在try后的括号内,并且可以通过；来进行分割声明多个Closeable对象，在try包裹内的代码执行完后都会被自动close掉。</p>
<h2 id="2kotlin的实现">2.kotlin的实现</h2>
<pre><code class="language-java">   val fis = FileInputStream(&quot;file_path&quot;)
    fis.use { 
        fis.read()
    }
</code></pre>
<p>通过使用use操作符来实现自动关闭Closeable对象，我们看一下use的源码：</p>
<pre><code class="language-java">@InlineOnly
@RequireKotlin(&quot;1.2&quot;, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = &quot;Requires newer compiler version to be inlined correctly.&quot;)
public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    var exception: Throwable? = null
    try {
        return block(this)
    } catch (e: Throwable) {
        exception = e
        throw e
    } finally {
        when {
            apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception)
            this == null -&gt; {}
            exception == null -&gt; close()
            else -&gt;
                try {
                    close()
                } catch (closeException: Throwable) {
                    // cause.addSuppressed(closeException) // ignored here
                }
        }
    }
}
</code></pre>
<p>一个高阶的内联函数，最终都是通过finally中进行关闭操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NDK开发-使用FMOD进行变声]]></title>
        <id>https://arms-merchants.github.io/post/ndk-kai-fa-shi-yong-fmod-jin-xing-bian-sheng/</id>
        <link href="https://arms-merchants.github.io/post/ndk-kai-fa-shi-yong-fmod-jin-xing-bian-sheng/">
        </link>
        <updated>2022-04-28T03:30:02.000Z</updated>
        <content type="html"><![CDATA[<p>FMOD一款强大的语音引擎，等同于视频届的FFMPEG.可以进行音频的多种修改和设置，它有提供客户端来进行直接使用，不过今天我们通过集成API来实现几个简单的变音效果。</p>
<h2 id="1ndk配置">1.NDK配置</h2>
<p>现在需要注意的是在新版本的AndroidStudio中已经不支持在local.properties设置中设置ndk.dir的配置来设置使用的NDK版本，如果需要配置的话通过下面的方式：</p>
<pre><code class="language-java">android{
    ndkVersion &quot;major.minor.build&quot; //ndkVersion &quot;21.3.6528147&quot;
}
</code></pre>
<p>如果不指定的话那么默认采用当前AGP支持的最高版本。<br>
导入fmod的文件，这里包括两个部分，一个是动态库（so库），一个是头文件<br>
通过头文件我们就可以使用对应的fmod的方法了。<br>
将fmod的inc头文件拷贝到cpp目录下，将so库拷贝到jinLibs（默认，也可以是指定的so库目录）<br>
修改默认的CMakeLists.txt文件：</p>
<pre><code class="language-java">#批量导入源文件，避免还需要一个个的导入源文件
file(GLOB allCPP *.c *.h *.cpp)

add_library( # Sets the name of the library.
        native-lib

        # Sets the library as a shared library.
         #SHARED 表示这个库是一个动态库 STATIC表示这个库是一个静态库，动态库是以.so文件结尾 静态库是以.a结尾，并且Android的话
        #在打包的最后只会包含有动态库，因为如果是静态库的话那么会将对应的代码拷贝到对应的地方，也就是在运行的时候不需要静态库了，而动态库对应的都是通过地址
        #来进行链接的，那么库文件还是需要的
        SHARED

        # Provides a relative path to your source file(s).
        //注意这里的名称要和上面批量导入的名称一致
        ${allCPP}
        )

#导入库文件，也就是三方的so，不过需要注意这个是需要在jniLibs中有对应文件夹后才能生效，不然会在编译阶段报错
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/../jniLibs/${CMAKE_ANDROID_ARCH_ABI}&quot;)
</code></pre>
<h2 id="2添加fmod的头文件和库">2.添加FMOD的头文件和库</h2>
<p>将下载的FMOD中对应的头文件文件夹inc拷贝到cpp目录下，在jniLibs中拷贝需要使用到的的架构目录。<br>
在CMakeLists.txt中添加配置信息：</p>
<pre><code class="language-java">#批量导入头文件,注意对应的目录，当前的根目录是CMakeLists.txt所在的目录
include_directories(&quot;inc&quot;)
#链接对应的库文件
target_link_libraries( # Specifies the target library.
        native-lib

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib}
        fmod
        fmodL
        )
</code></pre>
<p>完整的CMakeLists.txt文件：</p>
<pre><code class="language-java"># For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.10.2)

# Declares and names the project.

project(&quot;ndktest&quot;)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

#批量导入头文件
include_directories(&quot;inc&quot;)
#批量导入源文件
file(GLOB allCPP *.c *.h *.cpp)

add_library( # Sets the name of the library.
        native-lib

        # Sets the library as a shared library.
        SHARED

        # Provides a relative path to your source file(s).
        ${allCPP}
        )
#导入库文件，也就是三方的so
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/../jniLibs/${CMAKE_ANDROID_ARCH_ABI}&quot;)

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # Specifies the target library.
        native-lib

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib}
        fmod
        fmodL
        )
</code></pre>
<h2 id="3准备需要编辑的音频文件">3.准备需要编辑的音频文件</h2>
<p>这里我直接准备了一个mp3文件来进行编辑，当然也可以进行录制后编辑。在assets目录中放入mp3文件，这里为了方便操作，使用okio将文件拷贝到cache目录操作，这样也不需要进行权限的申请。</p>
<pre><code class="language-java">    implementation 'com.squareup.okio:okio:2.10.0'
</code></pre>
<p>拷贝文件：</p>
<pre><code class="language-java">    private fun copyFile(): String {
        //将assets目录下的文件拷贝到应用的cache目录下，这里的source是okio的扩展方法
        val targetFile = File(this.cacheDir, &quot;test.mp3&quot;)
        //使用use来自动关闭实现Closeable的对象
        this.assets.open(&quot;test.mp3&quot;).source().use { source -&gt;
            targetFile.sink().buffer().use {
                it.writeAll(source)
            }
        }
        return targetFile.path;
    }
</code></pre>
<h2 id="4使用ndk实现对应的方法调用">4.使用NDK实现对应的方法调用</h2>
<pre><code class="language-c++">#include &lt;jni.h&gt;
#include &lt;string&gt;

#include &lt;fmod.hpp&gt;

#include &quot;Student.h&quot;

using namespace std;
using namespace FMOD;

//android的log打印需要导入的头文件P
#include &lt;android/log.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
//宏定义
#define LOG_TAG &quot;ARM_NDK&quot;
//...的参数由__VA_ARGS__来进行确认
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__);
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__);

#undef MODE_NORMAL
#define MODE_NORMAL 0
#undef MODE_FUNNY
#define MODE_FUNNY 1
#undef MODE_UNCLE
#define MODE_UNCLE 2
#undef MODE_LOLITA
#define MODE_LOLITA 3
#undef MODE_ROBOT
#define MODE_ROBOT 4
#undef MODE_ETHEREAL
#define MODE_ETHEREAL 5
#undef MODE_CHORUS
#define MODE_CHORUS 6
#undef MODE_HORROR
#define MODE_HORROR 7

extern &quot;C&quot; {
//因为cpp是C++，如果要导入c的代码，需要使用c的语言环境
};

extern &quot;C&quot; JNIEXPORT
jstring JNICALL
Java_com_arms_ndktest_MainActivity_stringFromJNI(
        JNIEnv
        *env,
        jobject /* this */) {
    string hello = &quot;Hello from C++&quot;;
    LOGE(&quot;测试打印&quot;);
    auto *student = new Student(&quot;haha&quot;, 21);
    const char *str = student-&gt;getName().c_str();
    LOGE(&quot;%s&quot;, str);
    delete student;
    return env-&gt;
            NewStringUTF(hello.c_str());
}

//没有返回值的JNI方法,非静态方法，非静态方法的话这里是jobject
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_MainActivity_testNoReturnFromJNI(JNIEnv
                                                       *env,
                                                       jobject thiz
) {
    //如果是从java层传入的数组，那么直接修改操作只会在c++层生效，不会改变java层的数据
    jintArray jintArray1;
    int length = env-&gt;GetArrayLength(jintArray1);

    int *pInt = env-&gt;GetIntArrayElements(jintArray1, NULL);
    for (int i = 0; i &lt; length; i++) {
        *(pInt + i) += 100;
    }
    //通过下面的操作杆来达到修改对应java的数据，mode的模式0 刷新java数组，释放C++层数组 JNI_COMMIT:只提交只刷新Java数组，不释放C++,JNI_ABORT:只释放C++层数据
    env-&gt;ReleaseIntArrayElements(jintArray1, pInt, 0);
}
//一个测试方法，使用c++来构建一个java的对象，并设置其中的参数
void test(JNIEnv *env) {

    const char *className = &quot;com/arms/ndktest/PeopleBean&quot;;

    jclass pJclass = env-&gt;FindClass(className);
    //这种方式不会调用构造方法
    jobject pJobject = env-&gt;AllocObject(pJclass);
    //这种方式，说白了就是要传入一个方法，这个方法就是构造方法从而来执行指定的构造方法
    jmethodID pJmethodId = env-&gt;GetMethodID(pJclass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
    jobject object = env-&gt;NewObject(pJclass, pJmethodId);

    jmethodID setNameMethod = env-&gt;GetMethodID(pJclass, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);
    jmethodID setAageMethod = env-&gt;GetMethodID(pJclass, &quot;setAge&quot;, &quot;(I)V&quot;);

    jstring nameValue = env-&gt;NewStringUTF(&quot;123&quot;);

    env-&gt;CallVoidMethod(pJobject, setNameMethod, nameValue);
    env-&gt;CallVoidMethod(pJobject, setAageMethod, 11);

    env-&gt;DeleteLocalRef(pJclass);
    env-&gt;DeleteLocalRef(pJobject);
}

/**
最开始在MainActivity中来实现对应的方法，出入参数为播放的模式以及对应的音频文件路径
*/
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_MainActivity_voiceChangeNative(JNIEnv *env, jobject thiz, jint mode,
                                                     jstring path) {
    char *content_ = &quot;播放完毕&quot;;
    const char *path_ = env-&gt;GetStringUTFChars(path, NULL);
    LOGE(&quot;mode:%d&quot;, mode);
    System *system = 0;
    Sound *sound = 0;
    Channel *channel = 0;
    DSP *dsp = 0;
    System_Create(&amp;system);
    system-&gt;init(32, FMOD_INIT_NORMAL, 0);
    system-&gt;createSound(path_, FMOD_DEFAULT, 0, &amp;sound);
    system-&gt;playSound(sound, 0, false, &amp;channel);
    switch (mode) {
        case 1:
            content_ = &quot;原声播放&quot;;
            break;
        case 2:
            content_ = &quot;萝莉播放&quot;;
            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);
            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 2.0f);
            channel-&gt;addDSP(0, dsp);
            break;
        case 3:
            content_ = &quot;大叔播放&quot;;
            // 音调低 -- 大叔 0.7
            // 1.创建DSP类型的Pitch 音调条件
            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);
            // 2.设置Pitch音调调节2.0
            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 0.7f);
            // 3.添加音效进去 音轨
            channel-&gt;addDSP(0, dsp);
            break;
        case 4:
            content_ = &quot;搞怪播放&quot;;
            // 小黄人声音 频率快

            // 从音轨拿 当前 频率
            float mFrequency;
            channel-&gt;getFrequency(&amp;mFrequency);

            // 修改频率
            channel-&gt;setFrequency(mFrequency * 1.5f); // 频率加快  小黄人的声音
            break;
        case 5:
            content_ = &quot;惊悚播放&quot;;
            // TODO 音调低
            // 音调低 -- 大叔 0.7
            // 1.创建DSP类型的Pitch 音调条件
            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);
            // 2.设置Pitch音调调节2.0
            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 0.7f);
            // 3.添加音效进去 音轨
            channel-&gt;addDSP(0, dsp); // 第一个音轨

            // TODO 搞点回声
            // 回音 ECHO
            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);
            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 200); // 回音 延时    to 5000.  Default = 500.
            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 10); // 回音 衰减度 Default = 50   0 完全衰减了
            channel-&gt;addDSP(1, dsp); // 第二个音轨

            // TODO 颤抖
            // Tremolo 颤抖音 正常5    非常颤抖  20
            system-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO, &amp;dsp);
            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_FREQUENCY, 20); // 非常颤抖
            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_SKEW, 0.8f); // ？？？
            channel-&gt;addDSP(2, dsp); // 第三个音轨
            break;
        case 6:
            content_ = &quot;空灵播放&quot;;
            // 回音 ECHO
            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);
            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 200); // 回音 延时    to 5000.  Default = 500.
            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 10); // 回音 衰减度 Default = 50   0 完全衰减了
            channel-&gt;addDSP(0, dsp);
            break;
    }
    bool isPlayer = true;
    while (isPlayer) {
        channel-&gt;isPlaying(&amp;isPlayer);
        usleep(1000 * 1000);
    }
    sound-&gt;release();
    system-&gt;close();
    system-&gt;release();
    env-&gt;ReleaseStringUTFChars(path, path_);
}

Channel *channel = 0;

extern &quot;C&quot;
JNIEXPORT jint JNICALL
Java_com_arms_ndktest_FmodSound_saveSound(JNIEnv *env, jobject cls, jstring path_jstr, jint type,
                                          jstring save_jstr) {
    Sound *sound;
    DSP *dsp;
    bool playing = true;
    float frequency = 0;
    System *mSystem;
    JNIEnv *mEnv = env;
    int code = 0;
    System_Create(&amp;mSystem);
    const char *path_cstr = mEnv-&gt;GetStringUTFChars(path_jstr, NULL);
    LOGI(&quot;saveAiSound-%s&quot;, path_cstr);
    const char *save_cstr;
    if (save_jstr != NULL) {
        save_cstr = mEnv-&gt;GetStringUTFChars(save_jstr, NULL);
        LOGI(&quot;saveAiSound-save_path=%s&quot;, save_cstr)
    }
    try {
        if (save_jstr != NULL) {
            char cDest[200];
            strcpy(cDest, save_cstr);
            mSystem-&gt;setSoftwareFormat(8000, FMOD_SPEAKERMODE_MONO, 0); //设置采样率为8000，channel为1
            mSystem-&gt;setOutput(FMOD_OUTPUTTYPE_WAVWRITER); //保存文件格式为WAV
            mSystem-&gt;init(32, FMOD_INIT_NORMAL, cDest);
            mSystem-&gt;recordStart(0, sound, true);
        }
        //创建声音
        mSystem-&gt;createSound(path_cstr, FMOD_DEFAULT, NULL, &amp;sound);
        mSystem-&gt;playSound(sound, 0, false, &amp;channel);
        LOGI(&quot;saveAiSound-%s&quot;, &quot;save_start&quot;)
        switch (type) {
            case MODE_NORMAL:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_NORMAL&quot;);
                break;
            case MODE_FUNNY:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_FUNNY&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_NORMALIZE, &amp;dsp);
                channel-&gt;getFrequency(&amp;frequency);
                frequency = frequency * 1.6;
                channel-&gt;setFrequency(frequency);
                break;
            case MODE_UNCLE:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_UNCLE&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 0.8);
                channel-&gt;addDSP(0, dsp);
                break;
            case MODE_LOLITA:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_LOLITA&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 1.8);
                channel-&gt;addDSP(0, dsp);
                break;
            case MODE_ROBOT:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_ROBOT&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 50);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 60);
                channel-&gt;addDSP(0, dsp);
                break;
            case MODE_ETHEREAL:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_ETHEREAL&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 300);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 20);
                channel-&gt;addDSP(0, dsp);
                break;
            case MODE_CHORUS:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_CHORUS&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 100);
                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 50);
                channel-&gt;addDSP(0, dsp);
                break;
            case MODE_HORROR:
                LOGI(&quot;saveAiSound-%s&quot;, &quot;save MODE_HORROR&quot;)
                mSystem-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO, &amp;dsp);
                dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_SKEW, 0.8);
                channel-&gt;addDSP(0, dsp);
                break;
            default:
                break;
        }
        mSystem-&gt;update();
    } catch (...) {
        LOGE(&quot;saveAiSound-%s&quot;, &quot;save error!&quot;)
        code = 1;
        goto end;
    }
    while (playing) {
        usleep(1000);
        channel-&gt;isPlaying(&amp;playing);
    }
    LOGI(&quot;saveAiSound-%s&quot;, &quot;save over!&quot;)
    goto end;
    end:
    if (path_jstr != NULL) {
        mEnv-&gt;ReleaseStringUTFChars(path_jstr, path_cstr);
    }
    if (save_jstr != NULL) {
        mEnv-&gt;ReleaseStringUTFChars(save_jstr, save_cstr);
    }
    sound-&gt;release();
    mSystem-&gt;close();
    mSystem-&gt;release();
    return code;
}

extern &quot;C&quot;
JNIEXPORT jint JNICALL
Java_com_arms_ndktest_FmodSound_playSound(JNIEnv *env, jobject thiz, jstring path, jint type) {
}
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_FmodSound_stopPlay(JNIEnv *env, jobject thiz) {
    channel-&gt;stop();
}
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_FmodSound_resumePlay(JNIEnv *env, jobject thiz) {
    channel-&gt;stop();
    //检测当前的env执行过程是否有异常发生
    jthrowable pJthrowable = env-&gt;ExceptionOccurred();
    if (pJthrowable) {
        //主动清除异常
        env-&gt;ExceptionClear();
        //JNI中主动抛出异常
        jclass throwClass = env-&gt;FindClass(&quot;java/lang/NoSuchFieldError&quot;);
        env-&gt;ThrowNew(throwClass, &quot;dfsdf&quot;);
    }
}
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_FmodSound_pausePlay(JNIEnv *env, jobject thiz) {
    channel-&gt;stop();
}
extern &quot;C&quot;
JNIEXPORT jboolean JNICALL
Java_com_arms_ndktest_FmodSound_isPlaying(JNIEnv *env, jobject thiz) {
    bool isPlaying = false;
    channel-&gt;isPlaying(&amp;isPlaying);
    return isPlaying;
}

JavaVM *javaVm = nullptr;

/**
 * JNIEnv *env 不能跨越线程，可以跨越函数  解决方案通过JavaVM.attchCurrentThread获取子线程的JNIEnv
 * jobject thiz 不能跨越线程和函数  这个通过提升为全局变量来解决
 * JavaVM *javaVm 可以跨越线程和函数
 *
 * 动态注册的代码
 * @param javaVm
 * @return
 */
JNIEXPORT jint JNI_OnLoad(JavaVM *javaVm, void *) {
    //::javaVm = javaVm;
    JNIEnv *jniEnv = nullptr;
    int result = javaVm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;jniEnv), JNI_VERSION_1_6);
    if (result != JNI_OK) {
        return -1;
    }
    return JNI_VERSION_1_6;
}

class MyContext {
public:
    JNIEnv *jniEnv = nullptr;
    jobject instance = nullptr;
};

void *myThreadTaskAction(void *pVoid) {
    //这个函数中指针运行在子线程中
    MyContext *myContext = static_cast&lt;MyContext *&gt;(pVoid);
    JNIEnv *jniEnv = nullptr;
    //通过JavaVM.attchCurrentThread获取子线程的JNIEnv
    jint result = ::javaVm-&gt;AttachCurrentThread(&amp;jniEnv, nullptr);
    if (result != JNI_OK) {
        return 0;
    }
    jclass activityClass = jniEnv-&gt;GetObjectClass(myContext-&gt;instance);

    jmethodID methodId = jniEnv-&gt;GetMethodID(activityClass, &quot;showAlter&quot;, &quot;()V&quot;);

    jniEnv-&gt;CallVoidMethod(myContext-&gt;instance, methodId);

    ::javaVm-&gt;DetachCurrentThread();
    return nullptr;
}


/**
 * 在C++的子线程中回掉Java层代码
 */
extern &quot;C&quot;
JNIEXPORT void JNICALL
Java_com_arms_ndktest_MainActivity_callJNIAsync(JNIEnv *env, jobject thiz) {
    env-&gt;GetJavaVM(&amp;::javaVm);
    auto *myContext = new MyContext;
    myContext-&gt;jniEnv = env;
    //jobject thiz 不能跨越线程和函数  这个通过提升为全局变量来解决
    myContext-&gt;instance = env-&gt;NewGlobalRef(thiz);
    pthread_t pid;
    //c中的创建子线程
    pthread_create(&amp;pid, nullptr, myThreadTaskAction, myContext);
    pthread_join(pid, nullptr);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在不同版本下通过Hook来启动插件activity的流程]]></title>
        <id>https://arms-merchants.github.io/post/zai-bu-tong-ban-ben-xia-tong-guo-hook-lai-qi-dong-cha-jian-activity-de-liu-cheng/</id>
        <link href="https://arms-merchants.github.io/post/zai-bu-tong-ban-ben-xia-tong-guo-hook-lai-qi-dong-cha-jian-activity-de-liu-cheng/">
        </link>
        <updated>2022-03-21T01:16:29.000Z</updated>
        <content type="html"><![CDATA[<p>不论哪个版本在启动插件Activity之前都需要通过DexPathLoader来进行相应的加载，这个部分不在此次内容中。<br>
版本区分的话这里是根据Activity的启动流程差异来进行相应的替换，基本思路一致，版本划分的话主要是8.0以下，10.0以下，10.0及以上版本。</p>
<h2 id="1hook替换intent">1.Hook替换Intent</h2>
<pre><code class="language-java">    private const val TARGET_INTENT = &quot;target_intent&quot;
    fun hookAMS() {
        try {
            LogE(Build.VERSION.SDK_INT.toString())
            //1。获取Singleton对象
            val singletonFieldParams =
                when {
                    (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) -&gt; {
                        //8.0以下
                        &quot;android.app.ActivityManagerNative&quot; to &quot;gDefault&quot;
                    }
                    (Build.VERSION.SDK_INT&lt;Build.VERSION_CODES.Q)-&gt;{
                        //10.0以下
                        &quot;android.app.ActivityManager&quot; to &quot;IActivityManagerSingleton&quot;
                    }
                    else -&gt; {
                        //10.0及以上
                        &quot;android.app.ActivityTaskManager&quot; to &quot;IActivityTaskManagerSingleton&quot;
                    }
                }
            val aClass = Class.forName(singletonFieldParams.first)
            val singletonField = aClass.getDeclaredField(singletonFieldParams.second)
            singletonField.isAccessible = true
            val singleton = singletonField[null]
            val singletonClazz = Class.forName(&quot;android.util.Singleton&quot;)
            val mInstanceFiled = singletonClazz.getDeclaredField(&quot;mInstance&quot;)
            mInstanceFiled.isAccessible = true
            val mInstance = mInstanceFiled[singleton]

            //2。获取Singleton中的IActivityTaskManager对象,区分版本10以下
            val proxyClass =
                if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) {
                    Class.forName(&quot;android.app.IActivityManager&quot;)
                } else {
                    Class.forName(&quot;android.app.IActivityTaskManager&quot;)
                }
            //3.创建动态代理
            val newProxyInstance = Proxy.newProxyInstance(
                Thread.currentThread().contextClassLoader,
                arrayOf(proxyClass)
            ) { proxy, method, args -&gt; //这里已经代理了IActivityTaskManagerSingleton
                // 对象，那么它的方法执行都会到这里，那么我们只要要获取获取对应的方法，那么就可以获取方法中的参数
                //参数当中是有Intent，那么这里就可以修改为宿主中Activity来执行
                //只需要处理startActivities的方法
                //这里代理的对象方法是在android8以后的版本
                try {
                    var index = -1
                    if (&quot;startActivity&quot; == method.name) {
                        index = args.indexOfFirst { it is Intent }
                        val defIntent = args[index] as Intent
                        val proxyIntent = Intent()
                        proxyIntent.setClassName(
                            &quot;com.arm.arount&quot;, &quot;com&quot; +
                                    &quot;.arm.arount.ProxyActivity&quot;
                        )
                        proxyIntent.putExtra(TARGET_INTENT, defIntent)
                        args[index] = proxyIntent
                    }
                    method.invoke(mInstance, *args.orEmpty())
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            //4.修改singleton的代理对象
            mInstanceFiled[singleton] = newProxyInstance
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
</code></pre>
<p>到上面一步我们已经完成了hook startActivity的流程，并且将启动插件的Intent替换为了宿主代理的Intent，并在其中保存了原始的Intent。那么下一步我们就需要在合适的实际替换回原始的Intent。</p>
<h2 id="2替换回原始intent">2.替换回原始Intent</h2>
<p>先上代码：</p>
<pre><code class="language-java">fun hookHandleIntent() {
        try {
            //获取ActivityThread
            val aClass = Class.forName(&quot;android.app.ActivityThread&quot;)
            //获取它的静态实例对象
            val sCurrentActivityThread = aClass.getDeclaredField(&quot;sCurrentActivityThread&quot;)
            sCurrentActivityThread.isAccessible = true
            val activityThread = sCurrentActivityThread[null]
            val mHField = aClass.getDeclaredField(&quot;mH&quot;)
            mHField.isAccessible = true
            val handler = mHField[activityThread] as Handler
            val mCallbackField = Handler::class.java.getDeclaredField(&quot;mCallback&quot;)
            mCallbackField.isAccessible = true
            val callback = Handler.Callback { msg -&gt;
                try {
                    when (msg.what) {
                        //Android8.0以下的处理的LaunchActivity
                        100 -&gt; {
                            val intentField = msg.obj.javaClass.getDeclaredField(&quot;intent&quot;)
                            intentField.isAccessible = true
                            val proxyIntent: Intent = intentField.get(msg.obj) as Intent
                            val intent = proxyIntent.getParcelableExtra&lt;Intent?&gt;(TARGET_INTENT)
                            intent?.let {
                                intentField.set(msg.obj, it)
                            }
                        }
                        //8.0以上的生命周期入口
                        159 -&gt; {
                            val mActivityCallbacksField = msg.obj.javaClass.getDeclaredField(
                                &quot;mActivityCallbacks&quot;
                            )
                            mActivityCallbacksField.isAccessible = true
                            val mActivityCallbacks = mActivityCallbacksField[msg.obj] as List&lt;*&gt;
                            val launchActivityItem = mActivityCallbacks.firstOrNull {
                                &quot;android.app.servertransaction.LaunchActivityItem&quot; == it?.javaClass?.name
                            }
                            launchActivityItem?.let {
                                val mIntentField = it.javaClass.getDeclaredField(&quot;mIntent&quot;)
                                mIntentField.isAccessible = true
                                val proxyIntent = mIntentField[launchActivityItem] as Intent
                                val intent =
                                    proxyIntent.getParcelableExtra&lt;Intent&gt;(TARGET_INTENT)
                                if (intent != null) {
                                    mIntentField[launchActivityItem] = intent
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                //这里一定要返回false不然正常流程的handleMessage就执行不到了
                false
            }
            mCallbackField[handler] = callback
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
</code></pre>
<p>属性activity启动流程的因为都发现我们是在ActivityThread的mh的Handler中拦截消息的，Handler中有一个CallBack对象，可以在handleMessage之前拿到msg</p>
<pre><code class="language-java">    public void dispatchMessage(@NonNull Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                //这里就是一定要返回false的原因
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
</code></pre>
<p>在拿到msg之后我们需要处理以下8.0以下以及8.0以上的区分：<br>
· 在Android8.0以下时，是在ActivityThread的Handler中处理<br>
100-109这几个值来处理不同的生命周期的，并且在msg中可以直接获取到Intent对象。<br>
· 而在Android8.0以后，这几个值没有了，统一为159的入口，并通过状态模式来处理，并且相应的参数有封装，我们需要获取一些包装参数之后才能获取到Intent。</p>
<p>到这里插件的Activity就可以启动了，但是你会发现资源布局都没法加载，下面再说插件资源的加载。</p>
<hr>
<p>Hook的方式来进行插件化开发，很受系统版本的限制，并且随着Android系统版本的升级要做不同的适配。所以还有另外一种插件方案就是通过容器来实现插件化，这种方式不需要hook太多的系统代码，腾讯的Shadow插件就是这个来实现的，宿主的app中有的是容器的activity,编写的业务插件按原来的逻辑继承Activity，但是在编译打包的时候通过插件将其继承改为ShadowActivity，这里其实是改为了普通类，而在代理类中通过调用这些方法，从而实现了生命周期方法的调用，不过这里都避免不了加载插件的过程，所有DexClassLoader还是必须要加载使用的，这也是热修复的基础。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin反射]]></title>
        <id>https://arms-merchants.github.io/post/kotlin-fan-she/</id>
        <link href="https://arms-merchants.github.io/post/kotlin-fan-she/">
        </link>
        <updated>2022-03-15T07:26:22.000Z</updated>
        <content type="html"><![CDATA[<p>kotlin可以直接使用java的反射，如果要使用kotlin的反射，那么需要单独引入kotlin的反射库</p>
<pre><code class="language-java">implementation &quot;org.jetbrains.kotlin:kotlin-reflect&quot;  
</code></pre>
<p>那么这和Java对比的话有什么区别</p>
<h2 id="java">Java</h2>
<ul>
<li>
<p>优点：无需引入额外依赖，首次使用速度相对较快(这是因为它的信息都在虚拟机内)。</p>
</li>
<li>
<p>缺点：无法访问Kotlin语法特性，需要对Kotlin生成的字节码足够了解(这是因为Kotlin程序编译完之后也是个Java类，所以在Java反射视角下看到的Kotlin编译的状态和一般Java类无异，这个时候如果要通过反射访问Kotlin类的一些方法属性，必须要知道它编译什么样的字节码)</p>
</li>
</ul>
<h2 id="kotlin">kotlin</h2>
<ul>
<li>
<p>优点：支持访问Kotlin几乎所有特性，API设计兼容性更好。</p>
</li>
<li>
<p>缺点：额外引入了一个Kotlin反射库(这个库2.5M左右，编译后400KB)，首次调用会慢一些，这是因为Kotlin的反射信息是写到Metadata这个注解里面的(通过查看字节码可以看到，如下)，里面的数据通过Protobuf的数据格式序列化二进制写入，所以首次反射调用有一个获取注解并反序列化的过程)。</p>
</li>
</ul>
<pre><code class="language-kotlin">
@Metadata(
   mv = {1, 6, 0},
   k = 1,
   d1 = {&quot;\u0000\u001a\n\u0002\u0018\u0002\n\u0000\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\b\u0003\u0018\u0000*\n\b\u0000\u0010\u0001 \u0000*\u00020\u00022\u00020\u0003B\u0005¢\u0006\u0002\u0010\u0004J\u0013\u0010\u0005\u001a\u00020\u00062\u0006\u0010\u0007\u001a\u00028\u0000¢\u0006\u0002\u0010\b¨\u0006\t&quot;},
   d2 = {&quot;Lcom/qisan/kotlinstu/Dustbin;&quot;, &quot;T&quot;, &quot;Lcom/qisan/kotlinstu/Waste;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;put&quot;, &quot;&quot;, &quot;t&quot;, &quot;(Lcom/qisan/kotlinstu/Waste;)V&quot;, &quot;KotlinStu.app&quot;}
)
</code></pre>
<h2 id="一些在kotlin反射中的常用api">一些在Kotlin反射中的常用Api:</h2>
<pre><code class="language-java">        var cls: KClass&lt;String&gt; = String::class
        //KClass转为java的Class&lt;String&gt;
        var clsJava: Class&lt;String&gt; = cls.java
        //java的Class&lt;String&gt;转为KClass
        cls = clsJava.kotlin
        //获取定义在String类的属性，返回的是Collections
        val properties = cls.declaredMemberProperties
        //返回这个类中的所有方法
        cls.declaredFunctions
        //返回这个类中的所有非静态非扩展的函数
        cls.declaredMemberFunctions
        //返回这个类中中的扩展函数,注意看下面的类A
        cls.declaredMemberExtensionFunctions

        cls.isAbstract//是否是抽象类
        cls.isCompanion//是否是伴生对象
        cls.nestedClasses//获取当前类的内部类
        cls.objectInstance//如果是object，可以通过这个方法获取
</code></pre>
<h3 id="1declaredmemberextensionfunctions的式例">1.declaredMemberExtensionFunctions的式例</h3>
<pre><code class="language-java">class A {

    fun test(){
        //这里的反射属性通过这个是可以获取到这个String.pass的扩展方法
        A::class.declaredMemberExtensionFunctions
        //但是通过String是获取不到
        String::class.declaredMemberExtensionFunctions
        &quot;&quot;.pass()
    }

    fun String.pass(){
    }
}
</code></pre>
<p>在A的扩展函数中能够获取到String.pass的扩展方法，但是String::class.declaredMemberExtensionFunctions是没有的，而在顶级的扩展函数中是构建成静态方法的.</p>
<pre><code class="language-java">fun String.pass() {
    println(&quot;test&quot;)
}
//ktx.kt 对应到的java代码
@Metadata(
   mv = {1, 6, 0},
   k = 2,
   d1 = {&quot;\u0000\f\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010\u000e\n\u0000\u001a\n\u0010\u0000\u001a\u00020\u0001*\u00020\u0002¨\u0006\u0003&quot;},
   d2 = {&quot;pass&quot;, &quot;&quot;, &quot;&quot;, &quot;Arount.app&quot;}
)
public final class KtxKt {
   public static final void pass(@NotNull String $this$pass) {
      Intrinsics.checkNotNullParameter($this$pass, &quot;$this$pass&quot;);
      String var1 = &quot;test&quot;;
      System.out.println(var1);
   }
}
</code></pre>
<h3 id="2ktype的获取">2.KType的获取</h3>
<pre><code class="language-java">   fun testKType(){
        val mapType = typeOf&lt;Map&lt;String,Int&gt;&gt;()
        mapType.arguments.forEach {
            print(it)
        }
        /**
         * 输出结果：
         * kotlin.String
         * kotlin.Int
         * KType可以找到泛型实参
         */
    }
</code></pre>
<h3 id="3获取接口方法的返回的泛型实例参数类型">3.获取接口方法的返回的泛型实例参数类型</h3>
<pre><code class="language-java">interface Api{
    fun getUsers():List&lt;UserModel&gt;
}

data class UserModel(var id:Int,var name:String)

fun testGetFunParamsType(){
        Api::class.declaredFunctions.first { it.name == &quot;getUsers&quot; }
            .returnType.arguments.forEach {
                print(it)
            }
        //两者相同
        Api::getUsers.returnType.arguments.forEach {
            print(it)
        }
    }
</code></pre>
<h3 id="4获取实例对象上的泛型约束类型">4.获取实例对象上的泛型约束类型</h3>
<pre><code class="language-java">abstract class SuperType&lt;T&gt;{
    val typeParameter by lazy {
        //this表示的是子类的实例，因为抽象类不能用于创建实例，只能背当做父类被子类继承
        this::class.supertypes.first().arguments.first().type
        //如果有多个子类继承 比如class SubType2:SubType(){} 
        //这个时候this::class.supertype会空，因为SubType没有泛型实参这时候要使用：
        this::class.allSupertypes.first().arguments.first().type
    }
}

open class SubType:SuperType&lt;String&gt;()

class SubType2:SubType()

fun testGetParentType(){
    val subType = SubType()
    subType.typeParameter.let {
        print(it)
        //kotlin.String
    }
}
</code></pre>
<h2 id="场景引用-深层拷贝">场景引用-深层拷贝</h2>
<pre><code class="language-java">    data class Person(val id: Int, val name: String, val group: Group)
    data class Group(val id: Int, val name: String)

/**
 * 深层数据拷贝
 */
fun &lt;T:Any&gt; T.deepCopy():T{
    if(!this::class.isData){
        return this
    }
    return this::class.primaryConstructor!!.let { primaryConstructor-&gt;
        primaryConstructor.parameters.associate { parameter -&gt;
            val value =
                (this::class as KClass&lt;T&gt;).memberProperties.first { it.name == parameter.name }
                    .get(this)
            if ((parameter.type.classifier as? KClass&lt;*&gt;)?.isData == true) {
                parameter to value?.deepCopy()
            } else {
                parameter to value
            }
        }
            .let {
                primaryConstructor.callBy(it)
                //primaryConstructor是KFunction&lt;T&gt;类型 KFunction&lt;T&gt;里面有callBy方法 只要传一个map，返回调用者的参数类型T
            }
    }
}

    private fun testCopy() {
        val group = Group(1, &quot;11111&quot;)
        val person = Person(1, &quot;haha&quot;, group)
        //浅层拷贝实际上就是new了一个新的对象，并将当前类的属性传入，那么group就传入的是同一个了
        val copyPerson = person.copy()
        //也就是说通过copy的方法，实现的拷贝中group还是指向的同一个，那么相应的修改就会造成同步的修改
        Log.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, (person === copyPerson).toString()) //false
        Log.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, (person.group === copyPerson.group).toString()) //true

        //深层拷贝的第一次是真的慢
        val startTime = System.currentTimeMillis()
        val deepCope = person.deepCopy()
        val endTime = System.currentTimeMillis()

        Log.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, &quot;cost time:${endTime - startTime}&quot;)
        Log.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, (person === deepCope).toString()) //false
        Log.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;, (person.group === deepCope.group).toString()) //false
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ANR以及电量优化]]></title>
        <id>https://arms-merchants.github.io/post/anr-yi-ji-dian-liang-you-hua/</id>
        <link href="https://arms-merchants.github.io/post/anr-yi-ji-dian-liang-you-hua/">
        </link>
        <updated>2022-03-01T01:07:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="app启动优化分析"><a href="https://mp.weixin.qq.com/s/_8ZzgmmP4Ov66f42sBHslA">App启动优化分析</a></h1>
<h2 id="1anr是什么">1.ANR是什么？</h2>
<p>ANR(Application Not Responding)程序未响应，Android系统中如果在预定的时间内未得到有效的响应或响应时间过长，都会产生ANR，程序的响应性由ActivityManager和WindowManager系统服务监视。</p>
<h2 id="2anr的产生原因">2.ANR的产生原因？</h2>
<ul>
<li>对于前台服务，则超时为SERVICE_TIMEOUT = 20s；</li>
<li>对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT = 200s</li>
<li>对于前台广播，则超时为BROADCAST_FG_TIMEOUT = 10s；</li>
<li>对于后台广播，则超时为BROADCAST_BG_TIMEOUT = 60s;</li>
<li>ContentProvider超时为CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10s;</li>
<li>InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。</li>
</ul>
<p><code>注意事项: Input的超时机制与其他的不同，对于input来说即便某次事件执行时间超过timeout时长，只要用户后续在没有再生成输入事件，则不会触发ANR</code></p>
<ul>
<li>
<p>Service超时检测机制：</p>
<ul>
<li>超过一定时间没有执行完相应操作来触发移除延时消息，则会触发anr;</li>
</ul>
</li>
<li>
<p>BroadcastReceiver超时检测机制：</p>
<ul>
<li>有序广播的总执行时间超过 2* receiver个数 * timeout时长，则会触发anr;<br>
有序广播的某一个receiver执行过程超过 timeout时长，则会触发anr;</li>
</ul>
</li>
<li>
<p>另外:</p>
<ul>
<li>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding;</li>
<li>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框</li>
</ul>
</li>
</ul>
<h2 id="3anr的定位分析">3.ANR的定位分析</h2>
<ol>
<li>前台ANR发生后，系统会马上去抓取现场的信息，用于调试分析，收集的信息如下:</li>
</ol>
<ul>
<li>将am_anr信息输出到EventLog，也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息</li>
<li>收集以下重要进程的各个线程调用栈trace信息，保存在data/anr/traces.txt文件
<ul>
<li>当前发生ANR的进程，system_server进程以及所有persistent进程</li>
<li>audioserver, cameraserver, mediaserver, surfaceflinger等重要的native进程</li>
<li>CPU使用率排名前5的进程</li>
</ul>
</li>
<li>将发生ANR的reason以及CPU使用情况信息输出到main log</li>
<li>将traces文件和CPU使用情况信息保存到dropbox，即data/system/dropbox目录</li>
<li>对用户可感知的进程则弹出ANR对话框告知用户，对用户不可感知的进程发生ANR则直接杀掉</li>
</ul>
<ol start="2">
<li>分析步骤
<ol>
<li>定位发生ANR时间点</li>
<li>查看trace信息</li>
<li>分析是否有耗时的message,binder调用，锁的竞争，CPU资源的抢占</li>
<li>结合具体的业务场景的上下文来分析</li>
</ol>
</li>
</ol>
<h2 id="4电量优化工具">4.电量优化工具</h2>
<pre><code>Profiler - NetWork(网络分析),CPU（CPU使用分析，查看当前CPU运行的状态，判断卡顿发生时的状态）,Memory（内存使用分析，内存抖动，内存泄漏，OOM的分析）
</code></pre>
<h2 id="5电量优化方案">5.电量优化方案</h2>
<p>减少操作，例如数据下载是否每次都需要去更新最新的数据，是否有缓存的必要。<br>
推迟操作，一些耗电操作是否在特定的状态下（电量满或者充电状态下）进行，例如持续的定位<br>
合并操作<br>
DNS的优化：HTTPDNS，可以接入三方提供的dns解析，<a href="https://help.aliyun.com/product/30100.html"><code>阿里云HTTPDNS</code></a><br>
数据压缩：Ptotobuf</p>
<h3 id="阿里mavne"><a href="https://developer.aliyun.com/mvn/view"><code>阿里Mavne</code></a></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的数据结构分析]]></title>
        <id>https://arms-merchants.github.io/post/chang-yong-de-shu-ju-jie-gou-fen-xi/</id>
        <link href="https://arms-merchants.github.io/post/chang-yong-de-shu-ju-jie-gou-fen-xi/">
        </link>
        <updated>2022-02-22T01:37:02.000Z</updated>
        <content type="html"><![CDATA[<p>常用的数据结构<br>
ArrayList：底层由数组实现，所以它在内存中是一块连续的空间</p>
<pre><code class="language-java">/**
两种情况，一种是直接在添加，那么它是添加在数组的最后，这个时候只需要让size++的元素填充为e
*/
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
/**
在指定的位置插入，System.arraycopy首先会将当前index到数组最后的元素后移拷贝一份，再将插入的元素插入index
*/
    public void add(int index, E element) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
</code></pre>
<p>所以在add的时候如果是发生在中间的情况下，那么会发生一次数据拷贝</p>
<pre><code class="language-java">  public E remove(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        modCount++;
        E oldValue = (E) elementData[index];

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
</code></pre>
<p>remove的操作同理，取出index坐标下的对象，然后通过数据拷贝将index+1到末尾的数据向前拷贝一位，并将数组中最后一位置为null，等待GC。</p>
<pre><code class="language-java">        public E get(int index) {
            if (index &lt; 0 || index &gt;= this.size)
              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
            return (E) ArrayList.this.elementData[offset + index];
        }
</code></pre>
<p>而因为ArrayList在内存中是一个连续的内存空间，所以当它声明后它的地址是已知的，如果在内部存入一个Object的对象（4个字节）那么只需要在这个地址上加4就能查询到对应的数据。<br>
所以ArrayList在进行查询，和直接添加时效率高，但是在进行中间插入以及删除时会因为要进行一次数据拷贝，效率不高。<br>
与ArrayList通常进行比较的是LinkedList，一个由链表机构构成的数据结构，它在内存中不是一块连续的空间，双向链表。</p>
<pre><code class="language-java">    private static class Node&lt;E&gt; {
        //当前节点
        E item;
        //前驱
        Node&lt;E&gt; next;
        //后驱
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
</code></pre>
<p>链表结构带来的好处是，在进行数据插入和删除时，只需要修改节点的前驱和后驱指向就可以实现，并不需要进行数据的拷贝，但是如果要进行数据查询的话</p>
<pre><code class="language-java">    public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    }
    //返回指定下标的对象,get的实现也是通过这个方法来进行，所以我们没有办法通过第一个节点知道第10节点的对象，必须要进行循环查询。
    Node&lt;E&gt; node(int index) {
        // assert isElementIndex(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }
    //在succ之前插入一个元素，就是把succ的前驱节点设置给e，pred的后驱指向e，succ的前驱指向e，这样就完成了数据插入的操作。删除反之。
    void linkBefore(E e, Node&lt;E&gt; succ) {
        // assert succ != null;
        final Node&lt;E&gt; pred = succ.prev;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }
</code></pre>
<p>所以LinkedList是一种增删效率快，但是查询慢的数据结构。<br>
那么有没有一种数据结构是同时具有两者优点的，HashMap<br>
HashMap在1.7之前后之后的版本是不同的实现<br>
之前的HashMap结构是由数组➕链表构成的<br>
之后的HashMap是由数组➕链表➕红黑树构成的</p>
<p>hash碰撞的出现，以及解决方法？<br>
HashMap的默认大小-》16</p>
<pre><code class="language-java">  static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
</code></pre>
<p>HashMap什么时候扩容？由什么决定的？</p>
<p>长度为2的次幂的意义？<br>
减小碰撞的可能<br>
例子：<br>
Length1 =10<br>
Length2= 16</p>
<p>H1  110 = 6<br>
H2 111 = 7</p>
<p>L1 ：9 = 1001<br>
L2 ：15 = 1111</p>
<p>分别求模<br>
110<br>
1001   0000</p>
<p>111<br>
1001 0001</p>
<p>110<br>
1111   0110</p>
<p>111<br>
1111 0111<br>
可以发现非2次幂的情况下，中间两位为0，那么它就没有计算的意义，只有高位和低位有决定作用，而在2次幂的情况下，都为1那么都参与运算，减少了hashcode的冲突可能。</p>
<p>加载因子：</p>
<pre><code class="language-java">    static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>阙值：0.75*16（length） = 12，就是如果是默认长度的情况下，如果数组长度》=12的话，那么就扩容。</p>
<p>扩容的意义：均匀分布，减小冲突</p>
<p>Android特有的数据结构：<br>
SparseArray:双数组分别存储key和value，但key必须为int类型的数据，通过二分查找的方式去查询key的位置。<br>
ArrayMap:</p>
<pre><code class="language-java">        mHashes[index] = hash;
        mArray[index&lt;&lt;1] = key;
        mArray[(index&lt;&lt;1)+1] = value;
</code></pre>
<p>通过key的hash值查找在mHashes中的下标位置，并将key和value存入对应规则的indx下标对应的位置。<br>
这里解决了SparseArray的key只能为int类型的限制，也是通过两个数组实现，两个数组分别存储的是key的Hash值，另外一个数组存储的是key和value，所以mArray的长度是mHashes的2倍，在mArray的下标也是2倍为key，2倍加1为value。<br>
ArrayMap是如何解决Hash碰撞的：</p>
<pre><code class="language-java">int indexOf(Object key, int hash) {
        final int N = mSize;

        // Important fast case: if nothing is in here, nothing to look for.
        if (N == 0) {
            return ~0;
        }

        int index = binarySearchHashes(mHashes, N, hash);

        // If the hash code wasn't found, then we have no entry for this key.
        if (index &lt; 0) {
            return index;
        }

        // If the key at the returned index matches, that's what we want.
        //通过hash获取一个下标后，在实际存储key和value的数组中拿出来跟实际的key比较一下，
        //如果一样说明就是我们需要查找的下标位置
        if (key.equals(mArray[index&lt;&lt;1])) {
            return index;
        }

        // Search for a matching key after the index.
        int end;
        //因为如果出现hash碰撞的情况下，会将mHashes中存储的index加1直到没有冲突为止
        //上一步获取到的key和实际的key不一样，就是出现了hash碰撞，那么在以这个index+1的起点向右查找,因为hash发生了碰撞，那么在一个范围内存储的hash是一样的，我们只需要在这个一样hash范围内查找
        for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) {
            if (key.equals(mArray[end &lt;&lt; 1])) return end;
        }
        //向前查找
        // Search for a matching key before the index.
        for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) {
            if (key.equals(mArray[i &lt;&lt; 1])) return i;
        }

        // Key not found -- return negative value indicating where a
        // new entry for this key should go.  We use the end of the
        // hash chain to reduce the number of array entries that will
        // need to be copied when inserting.
        return ~end;
    }
</code></pre>
<p>所以相对于HashMap，这两者都是优化了内存空间的使用，因为HashMap是采用空间换时间的策略，只要到达75%的容量就会翻倍扩容，哪怕是只存储一个数据。</p>
<p>位运算：</p>
<ul>
<li>&lt;&lt;: 左移运算符号： num&lt;&lt;1 ,相当于num乘以2</li>
<li>
<blockquote>
<blockquote>
<p>: 右移运算符号： num&gt;&gt;1 ,相当于num除以2</p>
</blockquote>
</blockquote>
</li>
<li>
<blockquote>
<blockquote>
<blockquote>
<p>:无符号右移，忽略符号位，空位都以0补齐</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
</feed>